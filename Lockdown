#!/usr/bin/env bash
# mOSL/Lockdown

# Lockdown
#   Lockdown macOS High Sierra security settings

set -uo pipefail
# -e exit if any command returns non-zero status code
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

tput sgr0; # reset colors
RED=$(tput setaf 1)
RESET=$(tput sgr0)
BOLD=$(tput bold)

function usage {
  echo -e "\\nAudit or Fix macOS security settingsüîíüçé\\n"
  echo "Usage:"
  echo "  list         - List all items that can be audited/ fixed"
  echo "  audit        - Audit the status of all items (Does ${BOLD}NOT${RESET} change settings)"
  echo "  ${RED}fix${RESET}          - Attempt to fix all items (${BOLD}Does${RESET} change settings)"

  exit 0
}


### UTILITY FUNCTIONS ###


function compatability_check {

  # Check the system has at least Bash 4.x

  local bash_version
  bash_version="$(echo "${BASH_VERSION}" | awk -F '.' '{print $1}')"; 
  
  if [ "${bash_version}" -lt 4 ]; then 
    echo "[‚ùå] Sorry, this script requires Bash 4.x"
    echo "[üç∫] Current Bash version is ${BASH_VERSION}"
    echo "[‚¨áÔ∏è] brew install bash"
    exit 1
  fi
}


function audit {

  local title=${1:-"?"}
  local command=${2:-"?"}

  if bash -c "${command}"; then
    echo "[‚úÖ] ${title}"
    return 0
  else
    echo "[‚ùå] ${title}"
    return 1
  fi
}


function fix {

  local title=${1:-"?"}
  local command=${2}

  if [[ "${command}" == "null" ]]; then
    echo "[‚ö†Ô∏è ] ${title} has no command to remediate"
    return 1
  fi

  if bash -c "${command}"; then
    echo "[‚úÖ] ${title} fixed"
    return 0
  else
    echo "[‚ùå] Failed to fix ${title}"
    return 1
  fi
}


function mode_check {

  local mode=${1:-?}
  local title=${2:-?}
  local audit_command=${3:-?}
  local fix_command=${4:-"null"}

  if [[ "${mode}" == "audit" ]]; then
    audit "${title}" "${audit_command}"

  elif [[ "${mode}" == "fix" ]]; then
    fix "${title}" "${fix_command}"
  fi
}


function get_fix_mode_permission {

  # Double check with user before making changes to their system

  local fix_mode_permission
  fix_mode_permission=""

  echo "[‚ö†Ô∏è ] You are about to engage ${BOLD}${RED}FIX${RESET} mode which ${BOLD}${RED}WILL${RESET} make chnages to your Mac üíª"
  echo -n "[‚ö†Ô∏è ] Do you want to continue? (y/${BOLD}N${RESET}) "
  read -r fix_mode_permission

  if [[ "${fix_mode_permission}" =~ ^(y|Y)$ ]]; then
    
    echo "[‚úÖ] ${USER} has chosen to continue"
    echo "[‚ö†Ô∏è ] Your password is required to run some commands with 'sudo'"
    sleep 3
    return 0
  
  else
    echo "[‚ùå] ${USER} has chosen to quit"
    exit 1
  fi
}


### END UTILITY FUNCTIONS ###


function enable_automatic_updates {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Automatic Updates"

  audit_command="sudo softwareupdate --schedule | grep -q 'Automatic check is on'"
  fix_command="sudo softwareupdate --schedule on"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_gatekeeper {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Gatekeeper "

  audit_command='spctl --status | grep -q "assessments enabled"'
  fix_command='sudo spctl --master-enable'

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_firewall {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw  --getglobalstate | grep -q 'enabled'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_admin_password_preferences {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Require an administrator password to access system-wide preferences"

  audit_command="security -q authorizationdb read system.preferences | grep -A1 'shared' | grep -q 'false'"
  
  fix_command="security -q authorizationdb read system.preferences > /tmp/system.preferences.plist; /usr/libexec/PlistBuddy -c 'Set :shared false' /tmp/system.preferences.plist; security -q authorizationdb write system.preferences < /tmp/system.preferences.plist; rm '/tmp/system.preferences.plist'"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_firewall_builin_software {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable built-in software from being auto-permitted to listen through firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getallowsigned | grep 'built-in' | grep -q 'DISABLED'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setallowsigned off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_firewall_downloaded_signed {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable downloaded signed software from being auto-permitted to listen through firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getallowsigned | grep 'downloaded' | grep -q 'DISABLED'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setallowsignedapp off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_ipv6 {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable IPv6"

  # shellcheck disable=SC2016
  audit_command='while IFS= read -r i; do if networksetup -getinfo "${i}" | grep -q "IPv6: Off"; then :; else exit 1; fi; done <<< $(networksetup -listallnetworkservices | tail -n $(( $(networksetup -listallnetworkservices | wc -l) - 1 )))'
  
  # shellcheck disable=SC2016
  fix_command='while read -r i; do networksetup -setv6off "${i}"; done <<< "$(networksetup -listallnetworkservices | tail -n $(( $(networksetup -listallnetworkservices | wc -l) - 1 )))"'

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_mail_remote_content {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable automatic loading of remote content by Mail.app"

  audit_command="defaults read com.apple.mail-shared DisableURLLoading 2>/dev/null | grep -q '1'"
  
  fix_command="defaults write com.apple.mail-shared DisableURLLoading -int '1'"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_remote_apple_events {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable Remote Apple Events"

  audit_command="sudo systemsetup -getremoteappleevents | grep -q 'Remote Apple Events: Off'"
  
  fix_command="sudo systemsetup -setremoteappleevents off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function set_airdrop_contacts_only {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="AirDrop Discoverability: 'Contacts Only' or 'No One'"

  audit_command="if defaults read com.apple.sharingd DiscoverableMode 2>/dev/null | grep -q 'Contacts Only'; then exit 0; elif defaults read com.apple.sharingd DiscoverableMode 2>/dev/null | grep -q 'Off'; then exit 0; else exit 1; fi"

  fix_command="defaults write com.apple.sharingd DiscoverableMode -string 'Contacts Only' \
              && sudo killall -HUP sharingd"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_SIP {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check SIP enabled"

  audit_command="csrutil status | grep -q 'enabled'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_kext_loading_consent {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check Kernel Extension User Consent required"

  audit_command="spctl kext-consent status | grep -q 'ENABLED'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_EFI_integrity {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check EFI Firmware Integrity"

  audit_command="/usr/libexec/firmwarecheckers/eficheck/eficheck --integrity-check >/dev/null 2>&1"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_filevault {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check FileVault enabled"

  audit_command='diskutil apfs list | grep -q -i "FileVault:                 Yes"'
  fix_command=""

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function main {

  compatability_check
  # Check the system has at least Bash 4.x

  local cmd=${1:-"usage"}
  local items=()
  local all_functions

  all_functions="$(grep "^function" "${0}")"
  mapfile -t items < <(echo "${all_functions}" \
                      | awk '{print $2}' \
                      | awk -v top=6 -v bottom=1 'NR<=top{next};NR>bottom+top{print line[NR%bottom]};{line[NR%bottom]=$0}')
  # Build an array of all but the top 6 and bottom 1 function names
  # top NEEDS to be updated when new UTILITY functions are added

  if [[ "${cmd}" == "audit" ]]; then

    echo "[‚ö†Ô∏è ] Your password is required to run some commands with 'sudo'"
    
    for item in "${items[@]}"; do 
      "${item}" "audit"
      # Call functions in 'items' array with the argument 'audit'
    done

  elif [[ "${cmd}" == "fix" ]]; then

    # Confirm the user wants to run FIX mode
    get_fix_mode_permission

    for item in "${items[@]}"; do 

      if ! "${item}" "audit"; then
      # Run the audit command first
      # Only run the fix command if audit fails 
        "${item}" "fix"
      fi
    done

  elif [[ "${cmd}" == "list" ]]; then 
    
    echo "Items that can be audited or fixed: "
    for item in "${items[@]}"; do

      # shellcheck disable=SC2116
      item_read="$(echo "${item//_/ }")"
      # Replace underscore with a space, more human readable
      echo "  [üçé] ${item_read}"
    
    done

  else [[ "${cmd}" == "usage" ]];
    usage
  fi
}

main "$@"
