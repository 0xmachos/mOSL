#!/usr/bin/env bash
# mOSL/Lockdown

# Lockdown
#   Lockdown macOS High Sierra security settings

set -uo pipefail
# -e exit if any command returns non-zero status code
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

tput sgr0; # reset colors
RED=$(tput setaf 1)
RESET=$(tput sgr0)
BOLD=$(tput bold)

function usage {
  echo -e "\\nAudit or Fix macOS security settingsüîíüçé\\n"
  echo "Usage:"
  echo "  list         - List all items that can be audited/ fixed"
  echo "  audit        - Audit the status of all items (Does NOT change any settings)"
  echo "  fix          - Attempt to fix all items (${BOLD}${RED}Does${RESET} change settings)"

  exit 0
}


### UTILITY FUNCTIONS ###


function audit {

  local title=${1:-"?"}
  local command=${2:-"?"}

  if bash -c "${command}"; then
    echo "[‚úÖ] ${title}"
    return 0
  else
    echo "[‚ùå] ${title}"
    return 1
  fi
}

function fix {

  local title=${1:-"?"}
  local command=${2}

  if bash -c "${command}"; then
    echo "[‚úÖ] ${title} fixed"
    return 0
  else
    echo "[‚ùå] Failed to fix ${title}"
    return 1
  fi
}

function mode_check {

  local mode=${1:-?}
  local title=${2:-?}
  local audit_command=${3:-?}
  local fix_command=${4}

  if [[ "${mode}" == "audit" ]]; then
    audit "${title}" "${audit_command}"
  elif [[ "${mode}" == "fix" ]]; then
    fix "${title}" "${fix_command}"
  fi
}


function get_fix_mode_permission {

  # Double check with user before making changes to their system

  local fix_mode_permission
  fix_mode_permission=""

  echo "[‚ö†Ô∏è ] You are about to engage ${BOLD}${RED}FIX${RESET} mode which ${BOLD}${RED}WILL${RESET} make chnages to your Mac üíª"
  echo -n "[‚ö†Ô∏è ] Do you want to continue? (y/${BOLD}N${RESET}) "
  read -r fix_mode_permission

  if [[ "${fix_mode_permission}" =~ ^(y|Y)$ ]]; then
    
    echo "[‚úÖ] ${USER} has chosen to continue"
    echo "[‚ö†Ô∏è ] Your password is required to run some commands with 'sudo'"
    sleep 3
    return 0
  
  else
    echo "[‚ùå] ${USER} has chosen to quit"
    exit 1
  fi
}


### END UTILITY FUNCTIONS ###


function enable_automatic_updates {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Automatic Updates"

  audit_command="sudo softwareupdate --schedule | grep -q 'Automatic check is on'"
  fix_command="sudo softwareupdate --schedule on"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_bluetooth {
  
  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable Bluetooth"

  audit_command="defaults read /Library/Preferences/com.apple.Bluetooth ControllerPowerState | grep -q 0"
  fix_command="sudo defaults write /Library/Preferences/com.apple.Bluetooth ControllerPowerState -int 0 && sudo killall -HUP bluetoothd"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_filevault {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check FileVault"

  audit_command='diskutil apfs list | grep -q -i "FileVault:                 Yes"'
  fix_command=""

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function main {

  local cmd=${1:-"usage"}
  local items=()
  local all_functions

  all_functions="$(grep "^function" "${0}")"
  mapfile -t items < <(echo "${all_functions}" \
                      | awk '{print $2}' \
                      | awk -v top=5 -v bottom=1 'NR<=top{next};NR>bottom+top{print line[NR%bottom]};{line[NR%bottom]=$0}')
  # Build an array of all but the top 5 and bottom 1 function names
  # top NEEDS to be updated when new UTILITY functions are added

  if [[ "${cmd}" == "audit" ]]; then
    
    for item in "${items[@]}"; do 
      "${item}" "audit"
      # Call functions in 'items' array with the argument 'audit'
    done

  elif [[ "${cmd}" == "fix" ]]; then

    # Confirm the user wants to run FIX mode
    get_fix_mode_permission

    for item in "${items[@]}"; do 

      if ! "${item}" "audit"; then
      # Run the audit command first
      # Only run the fix command if audit fails 
        "${item}" "fix"
      fi
    done

  elif [[ "${cmd}" == "list" ]]; then 
    
    echo "Items that can be audited or fixed: "
    for item in "${items[@]}"; do

      # shellcheck disable=SC2116
      item_read="$(echo "${item//_/ }")"
      # Replace underscore with a space, more human readable
      echo "  [üçé] ${item_read}"
    
    done

  else [[ "${cmd}" == "usage" ]];
    usage
  fi
}

main "$@"
