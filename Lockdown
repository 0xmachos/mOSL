#!/usr/bin/env bash
# mOSL/Lockdown

# Lockdown
#   Lockdown macOS High Sierra security settings

set -uo pipefail
# -e exit if any command returns non-zero status code
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

tput sgr0; # reset colors
RED=$(tput setaf 1)
RESET=$(tput sgr0)
BOLD=$(tput bold)

function usage {
  echo -e "\\nAudit or Fix macOS security settingsüîíüçé\\n"
  echo "Usage:"
  echo "  list         - List all items that can be audited/ fixed"
  echo "  audit        - Audit the status of all items (Does NOT change any settings)"
  echo "  fix          - Attempt to fix all items (${BOLD}${RED}Does${RESET} change settings)"

  exit 0
}


### UTILITY FUNCTIONS ###


function compatability_check {

  # Check the system has at least Bash 4.x

  local bash_version
  bash_version="$(echo "${BASH_VERSION}" | awk -F '.' '{print $1}')"; 
  
  if [ "${bash_version}" -lt 4 ]; then 
    echo "[‚ùå] Sorry, this script requires Bash 4.x"
    echo "[üç∫] Your Bash version is ${BASH_VERSION}"
    echo "[‚¨áÔ∏è] brew install bash"
    exit 1
  fi
}


function audit {

  local title=${1:-"?"}
  local command=${2:-"?"}

  if bash -c "${command}"; then
    echo "[‚úÖ] ${title}"
    return 0
  else
    echo "[‚ùå] ${title}"
    return 1
  fi
}

function fix {

  local title=${1:-"?"}
  local command=${2}

  if [[ "${command}" == "null" ]]; then
    echo "[‚ö†Ô∏è ] ${title} has no command to remediate"
    return 1
  fi

  if bash -c "${command}"; then
    echo "[‚úÖ] ${title} fixed"
    return 0
  else
    echo "[‚ùå] Failed to fix ${title}"
    return 1
  fi
}

function mode_check {

  local mode=${1:-?}
  local title=${2:-?}
  local audit_command=${3:-?}
  local fix_command=${4:-"null"}

  if [[ "${mode}" == "audit" ]]; then
    audit "${title}" "${audit_command}"
  elif [[ "${mode}" == "fix" ]]; then
    fix "${title}" "${fix_command}"
  fi
}


function get_fix_mode_permission {

  # Double check with user before making changes to their system

  local fix_mode_permission
  fix_mode_permission=""

  echo "[‚ö†Ô∏è ] You are about to engage ${BOLD}${RED}FIX${RESET} mode which ${BOLD}${RED}WILL${RESET} make chnages to your Mac üíª"
  echo -n "[‚ö†Ô∏è ] Do you want to continue? (y/${BOLD}N${RESET}) "
  read -r fix_mode_permission

  if [[ "${fix_mode_permission}" =~ ^(y|Y)$ ]]; then
    
    echo "[‚úÖ] ${USER} has chosen to continue"
    echo "[‚ö†Ô∏è ] Your password is required to run some commands with 'sudo'"
    sleep 3
    return 0
  
  else
    echo "[‚ùå] ${USER} has chosen to quit"
    exit 1
  fi
}


### END UTILITY FUNCTIONS ###


function enable_automatic_updates {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Automatic Updates"

  audit_command="sudo softwareupdate --schedule | grep -q 'Automatic check is on'"
  fix_command="sudo softwareupdate --schedule on"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_filevault {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check FileVault enabled"

  audit_command='diskutil apfs list | grep -q -i "FileVault:                 Yes"'
  fix_command=""

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function set_airdrop_contacts_only {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="AirDrop Discoverability: Contacts Only"

  audit_command="defaults read com.apple.sharingd DiscoverableMode | grep -q 'Contacts Only'"
  
  fix_command="sudo defaults write com.apple.sharingd DiscoverableMode 'Contacts Only' \
              && sudo killall -HUP sharingd"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_gatekeeper {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check Gatekeeper enabled"

  audit_command='spctl --status | grep -q "assessments enabled"'
  fix_command='spctl --master-enable'

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_SIP {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check SIP enabled"

  audit_command="csrutil status | grep -q 'enabled'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_kext_loading_consent {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check Kernel Extension User Consent required"

  audit_command="spctl kext-consent status | grep -q 'ENABLED'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_EFI_integrity {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check EFI Firmware Integrity"

  audit_command="/usr/libexec/firmwarecheckers/eficheck/eficheck --integrity-check >/dev/null 2>&1"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_firewall {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Firewall"

  audit_command="defaults read /Library/Preferences/com.apple.alf globalstate | grep -q 1"
  
  fix_command="sudo defaults write /Library/Preferences/com.apple.alf globalstate -int '1'"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_firewall_builin_software {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable built-in software from being auto-permitted to listen through firewall"

  audit_command="defaults read /Library/Preferences/com.apple.alf allowsignedenabled | grep -q 0"
  
  fix_command="sudo defaults write /Library/Preferences/com.apple.alf allowsignedenabled -int '0' \
              && sudo killall -HUP socketfilterfw"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function main {

  compatability_check
  # Check the system has at least Bash 4.x

  local cmd=${1:-"usage"}
  local items=()
  local all_functions

  all_functions="$(grep "^function" "${0}")"
  mapfile -t items < <(echo "${all_functions}" \
                      | awk '{print $2}' \
                      | awk -v top=6 -v bottom=1 'NR<=top{next};NR>bottom+top{print line[NR%bottom]};{line[NR%bottom]=$0}')
  # Build an array of all but the top 6 and bottom 1 function names
  # top NEEDS to be updated when new UTILITY functions are added

  if [[ "${cmd}" == "audit" ]]; then
    
    for item in "${items[@]}"; do 
      "${item}" "audit"
      # Call functions in 'items' array with the argument 'audit'
    done

  elif [[ "${cmd}" == "fix" ]]; then

    # Confirm the user wants to run FIX mode
    get_fix_mode_permission

    for item in "${items[@]}"; do 

      if ! "${item}" "audit"; then
      # Run the audit command first
      # Only run the fix command if audit fails 
        "${item}" "fix"
      fi
    done

  elif [[ "${cmd}" == "list" ]]; then 
    
    echo "Items that can be audited or fixed: "
    for item in "${items[@]}"; do

      # shellcheck disable=SC2116
      item_read="$(echo "${item//_/ }")"
      # Replace underscore with a space, more human readable
      echo "  [üçé] ${item_read}"
    
    done

  else [[ "${cmd}" == "usage" ]];
    usage
  fi
}

main "$@"
