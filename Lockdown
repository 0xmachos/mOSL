#!/usr/bin/env bash
# mOSL/Lockdown

# Lockdown
#   Lockdown macOS High Sierra security settings

set -uo pipefail
# -e exit if any command returns non-zero status code
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

### Define Colours ###

tput sgr0; # reset colors

readonly RED="$(tput setaf 1)"
readonly RESET="$(tput sgr0)"
readonly BOLD="$(tput bold)"

### END Colours ###


function usage {
  echo -e "\\nAudit or Fix macOS security settings🔒🍎\\n"
  echo "Usage:"
  echo "  list         - List all settings that can be audited/ fixed"
  echo "  audit        - Audit the status of all settings (Does ${BOLD}NOT${RESET} change settings)"
  echo "  ${RED}fix${RESET}          - Attempt to fix all settings (${BOLD}Does${RESET} change settings)"

  exit 0
}


### UTILITY FUNCTIONS ###


function macos_compatability_check {

  # Check the system is running macOS 10.13

  local -r supported_macos_version="10.13"
  local -r supported_macos_name="High Sierra"
  local current_macos_version
  local current_macos_name
  current_macos_version="$(sw_vers -productVersion | awk -F '.' '{print $1 "." $2}')";


  if [ "${current_macos_version}" = "10.10" ]; then
    current_macos_name="Yosemite"

  elif [ "${current_macos_version}" = "10.11" ]; then
    current_macos_name="El Capitan"

  elif [ "${current_macos_version}" = "10.12" ]; then
    current_macos_name="Sierra"

  elif [ "${current_macos_version}" = "10.13" ]; then
    current_macos_name="High Sierra"
  
  else
    current_macos_name="🤷‍♂️"
  fi
  # This is terrible, afaik there's no command to get the release name 

  
  if [ "${current_macos_version}" != "${supported_macos_version}" ]; then 
    echo "[❌] Lockdown was built for macOS ${supported_macos_name} (${supported_macos_version}.x)"
    echo "[🍺] This is macOS ${current_macos_name} (${current_macos_version})"
    exit 1
  fi
}


function bash_compatability_check {

  # Check the system has at least Bash 4.x

  local bash_version
  bash_version="$(echo "${BASH_VERSION}" | awk -F '.' '{print $1}')"; 
  
  if [ "${bash_version}" -lt 4 ]; then 
    echo "[❌] Sorry, this script requires Bash 4.x"
    echo "[🍺] Current Bash version is ${BASH_VERSION}"
    echo "[⬇️] brew install bash"
    exit 1
  fi
}


function audit {

  local title=${1:-"?"}
  local command=${2:-"?"}

  if bash -c "${command}"; then
    echo "[✅] ${title}"
    return 0
  else
    echo "[❌] ${title}"
    return 1
  fi
}


function fix {

  local title=${1:-"?"}
  local command=${2}

  if [[ "${command}" == "null" ]]; then
    echo "[⚠️ ] ${BOLD}No fix_command${RESET}: ${title}"
    return 1
  fi

  if bash -c "${command}"; then
    echo "[✅] ${BOLD}FIXED${RESET}: ${title} "
    return 0
  else
    echo "[❌] ${BOLD}Failed to fix${RESET}: ${title}"
    return 1
  fi
}


function mode_check {

  local mode=${1:-?}
  local title=${2:-?}
  local audit_command=${3:-?}
  local fix_command=${4:-"null"}

  if [[ "${mode}" == "audit" ]]; then
    audit "${title}" "${audit_command}"

  elif [[ "${mode}" == "fix" ]]; then
    fix "${title}" "${fix_command}"
  fi
}


function get_fix_mode_permission {

  # Double check with user before making changes to their system

  local fix_mode_permission
  fix_mode_permission=""

  echo "[⚠️ ] You are about to engage ${BOLD}${RED}FIX${RESET} mode which ${BOLD}${RED}WILL${RESET} make changes to your Mac 💻"
  echo -n "[⚠️ ] Do you want to continue? (y/${BOLD}N${RESET}) "
  read -r fix_mode_permission

  if [[ "${fix_mode_permission}" =~ ^(y|Y)$ ]]; then
    
    echo "[✅] ${USER} has chosen to continue"
    sudo --prompt="[⚠️ ] Password required to run some commands with 'sudo': " : 2>/dev/null
    # Aquire sudo privlidges now so we can show a custom prompt
    # This tries to execute the bash null operator ':' which does nothing
    # Send stderr to /dev/null  
    sleep 3
    return 0
  
  else
    echo "[❌] ${USER} has chosen to quit"
    exit 1
  fi
}


### END UTILITY FUNCTIONS ###


function enable_automatic_updates {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Automatic Updates"

  audit_command="sudo softwareupdate --schedule | grep -q 'Automatic check is on'"
  fix_command="sudo softwareupdate --schedule on"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_gatekeeper {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Gatekeeper "

  audit_command='spctl --status | grep -q "assessments enabled"'
  fix_command='sudo spctl --master-enable'

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_firewall {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw  --getglobalstate | grep -q 'enabled'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_admin_password_preferences {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Require an administrator password to access system-wide preferences"

  audit_command="security -q authorizationdb read system.preferences | grep -A1 'shared' | grep -q 'false'"
  
  fix_command="security -q authorizationdb read system.preferences > /tmp/system.preferences.plist; /usr/libexec/PlistBuddy -c 'Set :shared false' /tmp/system.preferences.plist; sudo security -q authorizationdb write system.preferences < /tmp/system.preferences.plist; rm '/tmp/system.preferences.plist'"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_terminal_secure_entry {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Enable Terminal.app secure keyboard entry"

  audit_command="defaults read com.apple.Terminal SecureKeyboardEntry | grep -q '1'"
  
  fix_command="defaults write com.apple.Terminal SecureKeyboardEntry -bool true"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_firewall_builin_software {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable built-in software from being auto-permitted to listen through firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getallowsigned | grep 'built-in' | grep -q 'DISABLED'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setallowsigned off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_firewall_downloaded_signed {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable downloaded signed software from being auto-permitted to listen through firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getallowsigned | grep 'downloaded' | grep -q 'DISABLED'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setallowsignedapp off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_ipv6 {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable IPv6"

  # shellcheck disable=SC2016
  audit_command='while IFS= read -r i; do if networksetup -getinfo "${i}" | grep -q "IPv6: Off"; then :; else exit 1; fi; done <<< $(networksetup -listallnetworkservices | tail -n $(( $(networksetup -listallnetworkservices | wc -l) - 1 )))'
  
  # shellcheck disable=SC2016
  fix_command='while read -r i; do networksetup -setv6off "${i}"; done <<< "$(networksetup -listallnetworkservices | tail -n $(( $(networksetup -listallnetworkservices | wc -l) - 1 )))"'

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_mail_remote_content {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable automatic loading of remote content by Mail.app"

  audit_command="defaults read com.apple.mail-shared DisableURLLoading 2>/dev/null | grep -q '1'"
  
  fix_command="defaults write com.apple.mail-shared DisableURLLoading -int '1'"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_remote_apple_events {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable Remote Apple Events"

  audit_command="sudo systemsetup -getremoteappleevents | grep -q 'Remote Apple Events: Off'"
  
  fix_command="sudo systemsetup -setremoteappleevents off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_remote_login {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Disable Remote Login"

  audit_command="sudo systemsetup -getremotelogin | grep -q 'Remote Login: Off'"
  
  fix_command="sudo systemsetup -f -setremotelogin off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function set_airdrop_contacts_only {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="AirDrop Discoverability: 'Contacts Only' or 'No One'"

  audit_command="if defaults read com.apple.sharingd DiscoverableMode 2>/dev/null | grep -q 'Contacts Only'; then exit 0; elif defaults read com.apple.sharingd DiscoverableMode 2>/dev/null | grep -q 'Off'; then exit 0; else exit 1; fi"

  fix_command="defaults write com.apple.sharingd DiscoverableMode -string 'Contacts Only' \
              && sudo killall -HUP sharingd"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function set_appstore_update_check_daily {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Set AppStore update check to every one (1) day"

  audit_command="defaults read com.apple.SoftwareUpdate ScheduleFrequency 2>/dev/null | grep -q '1'"

  fix_command="defaults write com.apple.SoftwareUpdate ScheduleFrequency -int 1"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_SIP {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check SIP enabled"

  audit_command="csrutil status | grep -q 'enabled'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_kext_loading_consent {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check Kernel Extension User Consent required"

  audit_command="spctl kext-consent status | grep -q 'ENABLED'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_EFI_integrity {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check EFI Firmware Integrity"

  audit_command="/usr/libexec/firmwarecheckers/eficheck/eficheck --integrity-check >/dev/null 2>&1"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_filevault {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check FileVault enabled"

  audit_command='diskutil apfs list | grep -q -i "FileVault:                 Yes"'
  fix_command=""

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_firmware_password_set {

  local mode=${1:-?}
  local title
  local audit_command
  local fix_command
  
  title="Check firmware password set"

  audit_command="sudo firmwarepasswd -check | grep 'Yes'"
  fix_command=""

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


############################ 


function main {

  macos_compatability_check
  # Check the system is running macOS 10.13
  bash_compatability_check
  # Check the system has at least Bash 4.x

  local cmd=${1:-"usage"}
  local settings=()
  local all_functions

  all_functions="$(grep "^function" "${0}")"
  mapfile -t settings < <(echo "${all_functions}" \
                      | awk '{print $2}' \
                      | awk -v top=7 -v bottom=1 'NR<=top{next};NR>bottom+top{print line[NR%bottom]};{line[NR%bottom]=$0}')
  # Build an array of all but the top 7 (utility functions) and bottom 1 (main) function names
  # top NEEDS to be updated when new UTILITY functions are added

  if [[ "${cmd}" == "audit" ]]; then

    sudo --prompt="[⚠️ ] Password required to run some commands with 'sudo': " : 2>/dev/null
    
    for setting in "${settings[@]}"; do 
      "${setting}" "audit"
      # Call functions in 'settings' array with the argument 'audit'
    done

  elif [[ "${cmd}" == "fix" ]]; then

    # Confirm the user wants to run FIX mode
    get_fix_mode_permission

    for setting in "${settings[@]}"; do 

      if ! "${setting}" "audit" >/dev/null; then
      # Run the audit command first
      # Only run the fix command if audit fails 
        "${setting}" "fix"
      fi
    done

  elif [[ "${cmd}" == "list" ]]; then 
    
    echo "Settings (${BOLD}${#settings[@]}${RESET}) that can be audited or fixed: "
    for setting in "${settings[@]}"; do

      # shellcheck disable=SC2116
      setting_read="$(echo "${setting//_/ }")"
      # Replace underscore with a space, more human readable
      echo "  [🍎] ${setting_read}"
    
    done

  else
    usage
  fi
}

main "$@"
