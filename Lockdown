#!/usr/bin/env bash
# mOSL/Lockdown

# Lockdown
#   Lockdown macOS Mojave security settings

set -uo pipefail
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

### Define Colours ###

tput sgr0; 
# reset colors

readonly RED="$(tput setaf 1)"
readonly RESET="$(tput sgr0)"
readonly BOLD="$(tput bold)"

### END Colours ###


function usage {
  echo -e "\\nAudit or Fix macOS security settingsüîíüçé\\n"
  echo "Usage:"
  echo "  list         - List all settings that can be audited/ fixed"
  echo "  audit        - Audit the status of all settings (Does ${BOLD}NOT${RESET} change settings)"
  echo "  ${RED}fix${RESET}  {force} - Attempt to fix all settings (${BOLD}Does${RESET} change settings)"

  exit 0
}


### UTILITY FUNCTIONS ###
# macos_compatability_check
# audit
# fix
# mode_check
# get_fix_mode_permission
# verify_signature


function macos_compatability_check {

  # Check if running on a Mac
  # Check if the Mac is running the supoorted version of macOS 

  local -r supported_macos_name="Mojave"
  local -r supported_macos_version="10.14"
  local os
  local current_macos_version
  local current_macos_name

  os="$(uname -s)"

  if [[ "${os}" != "Darwin" ]]; then 
    echo "[‚ùå] Lockdown was built for macOS"
    exit 1
  fi

  current_macos_version="$(sw_vers -productVersion | awk -F '.' '{print $1 "." $2}')";
  current_macos_name="$(strings '/Applications/Utilities/System Information.app/Contents/MacOS/System Information' \
                        | grep 'macOS ' \
                        | tail -n 1 \
                        | awk '{print $2" "$3}')"
  # This is fragile. The awk statement will need to be updated for each major release
  # e.g Currentrly assumes OS name has two words, next release (Mojave) only has one 

  if [ "${current_macos_version}" != "${supported_macos_version}" ]; then 
    echo "[‚ùå] Lockdown was built for macOS ${supported_macos_name} (${supported_macos_version}.x)"
    echo "[üç∫] This is macOS ${current_macos_name} (${current_macos_version})"
    exit 1
  fi
}


function audit {

  local title=${1:?No title passed}
  local command=${2:?No command passed}

  if bash -c "${command}"; then
    echo "[‚úÖ] ${title}"
    return 0
  else
    echo "[‚ùå] ${title}"
    return 1
  fi
}


function fix {

  local title=${1:?No title passed}
  local command=${2:?No command passed}

  if [[ "${command}" == "null" ]]; then
    echo "[‚ö†Ô∏è ] ${BOLD}No fix_command${RESET}: ${title}"
    return 1
  fi

  if bash -c "${command}"; then
    echo "[‚úÖ] ${BOLD}FIXED${RESET}: ${title} "
    return 0
  else
    echo "[‚ùå] ${BOLD}Failed to fix${RESET}: ${title}"
    return 1
  fi
}


function mode_check {

  local mode=${1:?}
  local title=${2:?}
  local audit_command=${3:?}
  local fix_command=${4:-"null"}

  if [[ "${mode}" == "audit" ]]; then
    audit "${title}" "${audit_command}"

  elif [[ "${mode}" == "fix" ]]; then
    fix "${title}" "${fix_command}"
  fi
}


function get_fix_mode_permission {

  # Double check with user before making changes to their system

  local fix_mode_permission=""

  echo "[‚ö†Ô∏è ] You are about to engage ${BOLD}${RED}FIX${RESET} mode which ${BOLD}${RED}WILL${RESET} make changes to your Mac üíª"
  echo -n "[‚ö†Ô∏è ] Do you want to continue? (y/${BOLD}N${RESET}) "
  read -r fix_mode_permission

  if [[ "${fix_mode_permission}" =~ ^(y|Y)$ ]]; then
    
    echo "[‚úÖ] ${USER} has chosen to continue"
    sudo --prompt="[‚ö†Ô∏è ] Password required to run some commands with 'sudo': " : 2>/dev/null
    # Aquire sudo privlidges now so we can show a custom prompt
    # This tries to execute the bash null operator ':' which does nothing
    # Send stderr to /dev/null  
    sleep 3
    return 0
  
  else
    echo "[‚ùå] ${USER} has chosen to quit"
    exit 1
  fi
}


function verify_signature {
  
  # Verify Lockdown signature with minisign

  if [ -x "$(command -v minisign)" ]; then

    if ! minisign -Vm ./Lockdown -P "RWTiYbJbLl7q6uQ70l1XCvGExizUgEBNDPH0m/1yMimcsfgh542+RDPU" >/dev/null; then 
      echo "[‚ùå] Failed to validate Lockdown signature with minisign"
      exit 1
    fi

  else
    echo "[‚ö†Ô∏è ] Unable to verify Lockdown signature as minisign is not installed"
    echo "[üç∫] brew install minisign"
  fi
}


### END UTILITY FUNCTIONS ###


function enable_automatic_updates {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Enable Automatic Updates"

  audit_command="sudo softwareupdate --schedule | grep -q 'Automatic check is on'"
  fix_command="sudo softwareupdate --schedule on"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_gatekeeper {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Enable Gatekeeper "

  audit_command='spctl --status | grep -q "assessments enabled"'
  fix_command='sudo spctl --master-enable'

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_firewall {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Enable Firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw  --getglobalstate | grep -q 'enabled'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_admin_password_preferences {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Require an administrator password to access system-wide preferences"

  audit_command="security -q authorizationdb read system.preferences | grep -A1 'shared' | grep -q 'false'"
  
  fix_command="security -q authorizationdb read system.preferences > /tmp/system.preferences.plist; /usr/libexec/PlistBuddy -c 'Set :shared false' /tmp/system.preferences.plist; sudo security -q authorizationdb write system.preferences < /tmp/system.preferences.plist; rm '/tmp/system.preferences.plist'"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_terminal_secure_entry {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Enable Terminal.app secure keyboard entry"

  audit_command="defaults read com.apple.Terminal SecureKeyboardEntry | grep -q '1'"
  
  fix_command="defaults write com.apple.Terminal SecureKeyboardEntry -bool true"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_firewall_builin_software {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Disable built-in software from being auto-permitted to listen through firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getallowsigned | grep 'built-in' | grep -q 'DISABLED'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setallowsigned off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_firewall_downloaded_signed {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Disable downloaded signed software from being auto-permitted to listen through firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getallowsigned | grep 'downloaded' | grep -q 'DISABLED'"
  
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setallowsignedapp off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_ipv6 {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Disable IPv6"

  # shellcheck disable=SC2016
  audit_command='while IFS= read -r i; do if networksetup -getinfo "${i}" | grep -q "IPv6: Off"; then :; else exit 1; fi; done <<< $(networksetup -listallnetworkservices | tail -n $(( $(networksetup -listallnetworkservices | wc -l) - 1 )))'
  
  # shellcheck disable=SC2016
  fix_command='while read -r i; do networksetup -setv6off "${i}"; done <<< "$(networksetup -listallnetworkservices | tail -n $(( $(networksetup -listallnetworkservices | wc -l) - 1 )))"'

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_mail_remote_content {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Disable automatic loading of remote content by Mail.app"

  audit_command="defaults read com.apple.mail-shared DisableURLLoading 2>/dev/null | grep -q '1'"
  
  fix_command="defaults write com.apple.mail-shared DisableURLLoading -bool true"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_remote_apple_events {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Disable Remote Apple Events"

  audit_command="sudo systemsetup -getremoteappleevents | grep -q 'Remote Apple Events: Off'"
  
  fix_command="sudo systemsetup -setremoteappleevents off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_remote_login {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Disable Remote Login"

  audit_command="sudo systemsetup -getremotelogin | grep -q 'Remote Login: Off'"
  
  fix_command="sudo systemsetup -f -setremotelogin off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function set_airdrop_contacts_only {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="AirDrop Discoverability: 'Contacts Only' or 'No One'"

  audit_command="if defaults read com.apple.sharingd DiscoverableMode 2>/dev/null | grep -q 'Contacts Only'; then exit 0; elif defaults read com.apple.sharingd DiscoverableMode 2>/dev/null | grep -q 'Off'; then exit 0; else exit 1; fi"

  fix_command="defaults write com.apple.sharingd DiscoverableMode -string 'Contacts Only' \
              && sudo killall -HUP sharingd"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function set_appstore_update_check_daily {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Set AppStore update check to every one (1) day"

  audit_command="defaults read com.apple.SoftwareUpdate ScheduleFrequency 2>/dev/null | grep -q '1'"

  fix_command="defaults write com.apple.SoftwareUpdate ScheduleFrequency -int 1"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_SIP {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Check SIP enabled"

  audit_command="csrutil status | grep -q 'enabled'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_kext_loading_consent {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Check Kernel Extension User Consent required"

  audit_command="spctl kext-consent status | grep -q 'ENABLED'"
  fix_command=''

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_efi_integrity {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Check EFI Firmware Integrity"

  audit_command="/usr/libexec/firmwarecheckers/eficheck/eficheck --integrity-check >/dev/null 2>&1"
  fix_command=''

  if system_profiler SPiBridgeDataType | grep 'Model Name:' | grep -q 'T2'; then 
    echo "[‚ö†Ô∏è ] Check EFI Firmware Integrity ${RED}is not${RESET} supported by this Mac"
    return 1 
  fi
  
  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_filevault {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Check FileVault enabled"

  audit_command="fdesetup status | grep -q 'On'"
  fix_command=""

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function check_firmware_password_set {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  
  title="Check firmware password set"

  audit_command="sudo firmwarepasswd -check | grep -q 'Yes'"
  fix_command=""

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


############################ 


function main {

  verify_signature
  # Verify Lockdown signature 
  macos_compatability_check
  # Check the system is running the supoorted version of macOS 

  local cmd=${1:-"usage"}
  local settings=()

  settings=(enable_automatic_updates enable_gatekeeper enable_firewall enable_admin_password_preferences \
                  enable_terminal_secure_entry disable_firewall_builin_software disable_firewall_downloaded_signed\
                  disable_ipv6 disable_mail_remote_content disable_remote_apple_events disable_remote_login \
                  set_airdrop_contacts_only set_appstore_update_check_daily check_SIP check_kext_loading_consent \
                  check_efi_integrity check_filevault check_firmware_password_set)


  if [[ "${cmd}" == "audit" ]]; then

    sudo --prompt="[‚ö†Ô∏è ] Password required to run some commands with 'sudo': " : 2>/dev/null
    
    for setting in "${settings[@]}"; do 
      "${setting}" "audit"
      # Call functions in 'settings' array with the argument 'audit'
    done

  elif [[ "${cmd}" == "fix" ]]; then

    local fix_force=${2:-"false"}

    if [[ "${fix_force}" != "force" ]]; then
      # Confirm the user wants to run FIX mode
      # If "fix force" skip the prompt 
      get_fix_mode_permission
    fi

    for setting in "${settings[@]}"; do 

      if ! "${setting}" "audit" >/dev/null; then
      # Run the audit command first
      # Only run the fix command if audit fails 
        "${setting}" "fix"
      fi
    done

  elif [[ "${cmd}" == "list" ]]; then 
    
    echo "Settings (${BOLD}${#settings[@]}${RESET}) that can be audited or fixed: "
    for setting in "${settings[@]}"; do

      # shellcheck disable=SC2116
      setting_read="$(echo "${setting//_/ }")"
      # Replace underscore with a space, more human readable
      echo "  [üçé] ${setting_read}"
    
    done

  else
    usage
  fi
}

main "$@"
